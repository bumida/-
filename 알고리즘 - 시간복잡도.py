#!/usr/bin/env python
# coding: utf-8

# # 알고리즘 복잡도 표현 방법
# 
# 1. 알고리즘 복잡도 계산이 필요한 이유
# 
# 하나의 문제를 푸는 알고리즘은 다양할 수 있음.
# 
# 정수의 절대값 구하기
#   ex. 1, -1 >> 1
# - 방법1 : 정수값을 제곱한 값에 다시 루트를 씌우기
# - 방법2 : 정수가 음수인지 확인해서, 음수일 때만, -1을 곱하기
# 
# 다양한 알고리즘 중 어느 알고리즘이 더 좋은지를 분석하기 위해, 복잡도를 정의하고 계산한다.
# 
# 2. 알고리즘 복잡도 계산 항목
# 
# 1. 시간 복잡도 : 알고리즘 실행 속도
# 2. 공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈
# 
#     가장 중요한 시간 복잡도를 꼭 이해하고 계산할 수 있어야 한다.
#      
#  
# 
# 
# # 알고리즘 시간 복잡도의 주요 요소
# 
# 
# 
# - 반복문이 지배합니다.
#  - 마찬가지로, 포그래밍에서 시간 복잡도에 가장 영향을 많이 미치는 요소는 반복문
#  - 입력의 크기가 커지면 커질수록 반복문이 알고리즘 수행 시간을 지배함
#  
#  
# 
# 
# # 알고리즘 성능 표기법
#  
# 
# 
# 1. Big Ο(빅-오) 표기법: Ο(N)
#  - 알고리즘 최악의 실행 시간을 표기
#  - 가장 많이/일반적으로 사용함.
#  - 아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미이기 때문
#  
#  예:
#   만약 시간 복잡도 함수가 2n²+ 3n 이라면
#   - 가장 높은 차수는 2n²
#   - 상수는 실제 큰 영향이 없음
#   - 결국 빅 오 표기법으로는 Ο( n²)(서울부터 부산까지 가는 자동차의 예를 상기)
#  
#  2. Ω(오메가) 표기법 : Ω(N)
#  - 오메가 표기법은 알고리즘 최상의 실행 시간을 표기
#  
#  3. Θ(세타) 표기법 : Θ(N)
#  - 오메가 표기법은 알고리즘 평균 실행 시간을 표기
#  
#    
#    시간 복잡도 계산은 반복문이 핵심 요소임을 인지하고, 계산 표기는 최상, 평균, 최악 중, 최악의 시간인 
#    Big Ο 표기법을 중심으로 익히자.
#    
#    
# 
# 
# # 알고리즘1 : 1부터 n까지의 합을 구하는 알고리즘1
#    
# 
# 
# - 합을 기록할 변수를 만들고 O를 저장
#    - n을 1부터 1씩 증가하면서 반복
#    - 반복문 안에서 합을 기록할 변수에 1씩 증가된 값을 더함
#    - 반복이 끝나면 합을 출력
#   
#  

# In[11]:


def sum_all(n):
    total = 0
    for num in range(1,n + 1):
        total += num
    return total

sum_all(200)

########################

def sum_all2(n):
    return int(n*(n+1)/2)

sum_all2(20)


# In[ ]:





# In[ ]:




